"""
Golden Adaptive Strategy - Layer 3 of Three-Tier System

Strategy using the 4-dimensional Golden Adaptive indicators with:
1. Confidence-weighted position sizing
2. Regime-aware entry logic (trend-following vs mean-reversion)
3. Dynamic stops based on volatility dimension

This module is SELF-CONTAINED - can be removed without affecting other code.

Usage:
    from backend.golden_system import GoldenAdaptiveStrategy

    strategy = GoldenAdaptiveStrategy(bars, symbol="SPY")
    for i in range(len(bars)):
        orders = strategy.get_orders(bars, i, current_position)
"""

import numpy as np
from dataclasses import dataclass
from typing import Optional, List

from backend.golden_system.computation import (
    compute_golden_adaptive_indicators,
    generate_golden_signals,
)


@dataclass
class GoldenOrder:
    """Order generated by the Golden Adaptive Strategy."""
    side: str          # "BUY" or "SELL"
    shares: int        # Position size
    entry_price: float
    stop_loss: float
    take_profit: Optional[float] = None
    confidence: float = 0.0
    regime: str = "neutral"
    signal_strength: float = 0.0


@dataclass
class GoldenPosition:
    """Track current position state."""
    side: str          # "LONG" or "SHORT"
    shares: int
    entry_price: float
    stop_loss: float
    take_profit: Optional[float]
    entry_bar: int
    confidence: float
    regime: str


class GoldenAdaptiveStrategy:
    """
    Strategy using the 4-dimensional Golden Adaptive system.

    Key Features:
    1. Confidence-weighted position sizing (high confidence = larger size)
    2. Regime-aware entries (trend-following when trending, mean-reversion when choppy)
    3. Dynamic stops based on ATR and volatility regime
    4. Only trades when dimensions agree (confidence > threshold)
    """

    def __init__(
        self,
        bars: np.ndarray,
        symbol: str = "",
        initial_capital: float = 100000.0,
        risk_per_trade: float = 0.01,      # 1% risk per trade
        max_position_pct: float = 0.20,    # Max 20% of capital per position
        # Indicator parameters
        fractal_lookback: int = 20,
        vol_lookback: int = 14,
        er_period: int = 10,
        volume_period: int = 20,
        slow_period: int = 30,
        fast_period: int = 2,
        # Dimension weights
        w_fractal: float = 0.30,
        w_efficiency: float = 0.30,
        w_volatility: float = 0.25,
        w_volume: float = 0.15,
    ):
        """
        Initialize strategy with price data.

        Parameters
        ----------
        bars : np.ndarray
            OHLCV data with shape (N, 5)
        symbol : str
            Asset symbol for logging
        initial_capital : float
            Starting capital
        risk_per_trade : float
            Fraction of capital to risk per trade
        max_position_pct : float
            Maximum position as fraction of capital
        """
        self.bars = bars
        self.symbol = symbol
        self.initial_capital = initial_capital
        self.capital = initial_capital
        self.risk_per_trade = risk_per_trade
        self.max_position_pct = max_position_pct

        # Compute all indicators
        self.indicators = compute_golden_adaptive_indicators(
            bars,
            fractal_lookback=fractal_lookback,
            vol_lookback=vol_lookback,
            er_period=er_period,
            volume_period=volume_period,
            slow_period=slow_period,
            fast_period=fast_period,
            w_fractal=w_fractal,
            w_efficiency=w_efficiency,
            w_volatility=w_volatility,
            w_volume=w_volume,
        )

        # Pre-compute ATR for stops
        self.atr = self._calculate_atr(bars[:, 1], bars[:, 2], bars[:, 3], vol_lookback)

        # Generate signals (TRUE NO MAGIC NUMBERS - crossovers and rolling extremes)
        self.signals = generate_golden_signals(
            bars[:, 3],
            self.indicators['golden_ema'],
            self.indicators['golden_ema_fast'],
            self.indicators['golden_ema_slow'],
            self.indicators['confidence'],
            self.indicators['regime'],
            lookback=fractal_lookback,  # Use same lookback as indicators
        )

        # Warmup period
        self.warmup = max(2 * fractal_lookback, vol_lookback + 1, er_period, volume_period) + 10

    def _calculate_atr(
        self,
        high: np.ndarray,
        low: np.ndarray,
        close: np.ndarray,
        period: int
    ) -> np.ndarray:
        """Calculate ATR for stop placement."""
        n = len(high)
        tr = np.full(n, np.nan)
        atr = np.full(n, np.nan)

        tr[0] = high[0] - low[0]
        for i in range(1, n):
            tr[i] = max(
                high[i] - low[i],
                abs(high[i] - close[i-1]),
                abs(low[i] - close[i-1])
            )

        if n < period + 1:
            return atr

        # Initial ATR
        atr[period] = np.mean(tr[1:period+1])

        # Wilder's smoothing
        for i in range(period + 1, n):
            atr[i] = (atr[i-1] * (period - 1) + tr[i]) / period

        return atr

    def get_regime_label(self, regime_value: float) -> str:
        """Convert regime number to label."""
        if regime_value == 0.0:
            return "mean_reversion"
        elif regime_value == 2.0:
            return "trending"
        return "neutral"

    def calculate_position_size(
        self,
        entry_price: float,
        stop_price: float,
        confidence: float
    ) -> int:
        """
        Calculate position size based on risk and confidence.

        Position size scales with confidence.
        No magic numbers - uses actual risk calculation.
        """
        if entry_price <= 0 or stop_price <= 0:
            return 0

        risk_amount = self.capital * self.risk_per_trade * confidence
        risk_per_share = abs(entry_price - stop_price)

        # Minimum risk per share: avoid division issues
        # Use tiny fraction of entry price instead of magic number
        min_risk = entry_price * 1e-6
        if risk_per_share < min_risk:
            return 0

        shares = int(risk_amount / risk_per_share)

        # Enforce max position size
        max_shares = int(self.capital * self.max_position_pct / entry_price)
        shares = min(shares, max_shares)

        return max(0, shares)

    def calculate_stop_loss(
        self,
        entry_price: float,
        is_long: bool,
        bar_index: int,
        regime: float
    ) -> float:
        """
        Calculate stop loss based on ATR and regime.

        Trending regime: Wider stops (2.5x ATR) to let trends run
        Mean-reversion: Tighter stops (1.5x ATR) for quick exits
        Neutral: Medium stops (2.0x ATR)
        """
        atr = self.atr[bar_index]
        if np.isnan(atr) or atr <= 0:
            atr = entry_price * 0.02  # Fallback: 2% of price

        # ATR multiplier based on regime
        if regime == 2.0:  # Trending
            atr_mult = 2.5
        elif regime == 0.0:  # Mean-reversion
            atr_mult = 1.5
        else:  # Neutral
            atr_mult = 2.0

        stop_distance = atr * atr_mult

        if is_long:
            return entry_price - stop_distance
        else:
            return entry_price + stop_distance

    def calculate_take_profit(
        self,
        entry_price: float,
        stop_price: float,
        is_long: bool,
        regime: float
    ) -> Optional[float]:
        """
        Calculate take profit based on risk:reward ratio.

        Trending regime: Higher R:R (3:1) to capture full moves
        Mean-reversion: Lower R:R (1.5:1) for quick profits
        Neutral: Medium R:R (2:1)
        """
        risk = abs(entry_price - stop_price)

        if regime == 2.0:  # Trending
            reward_ratio = 3.0
        elif regime == 0.0:  # Mean-reversion
            reward_ratio = 1.5
        else:  # Neutral
            reward_ratio = 2.0

        reward = risk * reward_ratio

        if is_long:
            return entry_price + reward
        else:
            return entry_price - reward

    def get_orders(
        self,
        bars: np.ndarray,
        bar_index: int,
        position: Optional[GoldenPosition] = None
    ) -> List[GoldenOrder]:
        """
        Generate orders for the current bar.

        Parameters
        ----------
        bars : np.ndarray
            Price data
        bar_index : int
            Current bar index
        position : GoldenPosition, optional
            Current open position (None if flat)

        Returns
        -------
        List[GoldenOrder]
            Orders to execute (empty if no action)
        """
        if bar_index < self.warmup:
            return []

        orders = []
        close = bars[bar_index, 3]
        signal = self.signals[bar_index]
        confidence = self.indicators['confidence'][bar_index]
        regime = self.indicators['regime'][bar_index]

        # Check for exit conditions if we have a position
        if position is not None:
            should_exit = False
            exit_reason = ""

            # Stop loss hit
            if position.side == "LONG" and bars[bar_index, 2] <= position.stop_loss:
                should_exit = True
                exit_reason = "stop_loss"
            elif position.side == "SHORT" and bars[bar_index, 1] >= position.stop_loss:
                should_exit = True
                exit_reason = "stop_loss"

            # Take profit hit
            if position.take_profit is not None:
                if position.side == "LONG" and bars[bar_index, 1] >= position.take_profit:
                    should_exit = True
                    exit_reason = "take_profit"
                elif position.side == "SHORT" and bars[bar_index, 2] <= position.take_profit:
                    should_exit = True
                    exit_reason = "take_profit"

            # Regime change exit (optional - exit if regime flips against position)
            current_regime = self.get_regime_label(regime)
            if position.regime == "trending" and current_regime == "mean_reversion":
                should_exit = True
                exit_reason = "regime_change"
            elif position.regime == "mean_reversion" and current_regime == "trending":
                should_exit = True
                exit_reason = "regime_change"

            # Signal reversal (exit when opposite signal generated)
            if position.side == "LONG" and signal < 0:
                should_exit = True
                exit_reason = "signal_reversal"
            elif position.side == "SHORT" and signal > 0:
                should_exit = True
                exit_reason = "signal_reversal"

            if should_exit:
                exit_side = "SELL" if position.side == "LONG" else "BUY"
                orders.append(GoldenOrder(
                    side=exit_side,
                    shares=position.shares,
                    entry_price=close,
                    stop_loss=0.0,
                    confidence=confidence if not np.isnan(confidence) else 0.0,
                    regime=current_regime,
                    signal_strength=signal
                ))
                return orders

        # Check for entry if no position
        # Signal is already confidence-weighted, check if non-zero
        if position is None and abs(signal) > 0:
            if np.isnan(confidence):
                return []

            is_long = signal > 0
            entry_price = close

            # Calculate stop and target
            stop_loss = self.calculate_stop_loss(entry_price, is_long, bar_index, regime)
            take_profit = self.calculate_take_profit(entry_price, stop_loss, is_long, regime)

            # Calculate position size (scaled by confidence)
            shares = self.calculate_position_size(entry_price, stop_loss, confidence)

            if shares > 0:
                orders.append(GoldenOrder(
                    side="BUY" if is_long else "SELL",
                    shares=shares,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    confidence=confidence,
                    regime=self.get_regime_label(regime),
                    signal_strength=signal
                ))

        return orders

    def update_capital(self, new_capital: float) -> None:
        """Update available capital (after trade P&L)."""
        self.capital = new_capital

    def get_indicator_state(self, bar_index: int) -> dict:
        """Get current state of all indicators for debugging."""
        return {
            'golden_ema': self.indicators['golden_ema'][bar_index],
            'golden_ema_fast': self.indicators['golden_ema_fast'][bar_index],
            'golden_ema_slow': self.indicators['golden_ema_slow'][bar_index],
            'alpha': self.indicators['alpha'][bar_index],
            'confidence': self.indicators['confidence'][bar_index],
            'regime': self.get_regime_label(self.indicators['regime'][bar_index]),
            'signal': self.signals[bar_index],
            'atr': self.atr[bar_index],
            'alpha_fractal': self.indicators['alpha_fractal'][bar_index],
            'alpha_volatility': self.indicators['alpha_volatility'][bar_index],
            'alpha_efficiency': self.indicators['alpha_efficiency'][bar_index],
            'alpha_volume': self.indicators['alpha_volume'][bar_index],
        }


# =============================================================================
# Backtest Runner
# =============================================================================

@dataclass
class BacktestResult:
    """Results from backtesting the Golden Adaptive Strategy."""
    symbol: str
    total_return: float
    sharpe_ratio: float
    max_drawdown: float
    win_rate: float
    n_trades: int
    avg_confidence: float
    regime_breakdown: dict
    equity_curve: np.ndarray


def backtest_golden_strategy(
    bars: np.ndarray,
    symbol: str = "",
    initial_capital: float = 100000.0,
    **strategy_kwargs
) -> BacktestResult:
    """
    Run backtest on the Golden Adaptive Strategy.

    Parameters
    ----------
    bars : np.ndarray
        OHLCV data
    symbol : str
        Asset symbol
    initial_capital : float
        Starting capital
    **strategy_kwargs
        Additional arguments for GoldenAdaptiveStrategy

    Returns
    -------
    BacktestResult
        Backtest performance metrics
    """
    strategy = GoldenAdaptiveStrategy(
        bars, symbol=symbol, initial_capital=initial_capital, **strategy_kwargs
    )

    n_bars = len(bars)
    equity = np.full(n_bars, initial_capital)
    position: Optional[GoldenPosition] = None
    trades = []
    confidences = []

    for i in range(n_bars):
        # Update equity
        if i > 0:
            equity[i] = equity[i-1]

        # Get orders
        orders = strategy.get_orders(bars, i, position)

        for order in orders:
            if position is None:
                # Entry
                position = GoldenPosition(
                    side="LONG" if order.side == "BUY" else "SHORT",
                    shares=order.shares,
                    entry_price=order.entry_price,
                    stop_loss=order.stop_loss,
                    take_profit=order.take_profit,
                    entry_bar=i,
                    confidence=order.confidence,
                    regime=order.regime
                )
                confidences.append(order.confidence)
            else:
                # Exit
                if position.side == "LONG":
                    pnl = (order.entry_price - position.entry_price) * position.shares
                else:
                    pnl = (position.entry_price - order.entry_price) * position.shares

                equity[i] += pnl
                strategy.update_capital(equity[i])

                trades.append({
                    'entry_bar': position.entry_bar,
                    'exit_bar': i,
                    'side': position.side,
                    'pnl': pnl,
                    'confidence': position.confidence,
                    'regime': position.regime
                })

                position = None

    # Calculate metrics
    returns = np.diff(equity) / equity[:-1]
    returns = returns[~np.isnan(returns)]

    total_return = (equity[-1] - initial_capital) / initial_capital

    if len(returns) > 0 and np.std(returns) > 0:
        sharpe = np.mean(returns) / np.std(returns) * np.sqrt(252)
    else:
        sharpe = 0.0

    # Max drawdown
    peak = np.maximum.accumulate(equity)
    drawdown = (peak - equity) / peak
    max_dd = np.max(drawdown)

    # Win rate
    if trades:
        wins = sum(1 for t in trades if t['pnl'] > 0)
        win_rate = wins / len(trades)
    else:
        win_rate = 0.0

    # Regime breakdown
    regime_breakdown = {'trending': 0, 'mean_reversion': 0, 'neutral': 0}
    for t in trades:
        regime_breakdown[t['regime']] = regime_breakdown.get(t['regime'], 0) + 1

    return BacktestResult(
        symbol=symbol,
        total_return=total_return,
        sharpe_ratio=sharpe,
        max_drawdown=max_dd,
        win_rate=win_rate,
        n_trades=len(trades),
        avg_confidence=np.mean(confidences) if confidences else 0.0,
        regime_breakdown=regime_breakdown,
        equity_curve=equity
    )


def print_backtest_result(result: BacktestResult) -> None:
    """Pretty print backtest results."""
    print("\n" + "=" * 60)
    print(f"  GOLDEN ADAPTIVE STRATEGY - BACKTEST RESULTS")
    print(f"  Symbol: {result.symbol}")
    print("=" * 60)

    print(f"\n[Performance]")
    print(f"  Total Return:   {result.total_return*100:>8.2f}%")
    print(f"  Sharpe Ratio:   {result.sharpe_ratio:>8.2f}")
    print(f"  Max Drawdown:   {result.max_drawdown*100:>8.2f}%")

    print(f"\n[Trading]")
    print(f"  Total Trades:   {result.n_trades:>8}")
    print(f"  Win Rate:       {result.win_rate*100:>8.1f}%")
    print(f"  Avg Confidence: {result.avg_confidence:>8.2f}")

    print(f"\n[Regime Breakdown]")
    for regime, count in result.regime_breakdown.items():
        pct = count / result.n_trades * 100 if result.n_trades > 0 else 0
        print(f"  {regime:<15}: {count:>4} ({pct:.1f}%)")

    print("=" * 60 + "\n")
